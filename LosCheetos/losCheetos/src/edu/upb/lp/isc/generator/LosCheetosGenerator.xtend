/*
 * generated by Xtext 2.11.0
 */
package edu.upb.lp.isc.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import edu.upb.lp.isc.losCheetos.Expression
import edu.upb.lp.isc.losCheetos.Define
import edu.upb.lp.isc.losCheetos.MyRacketProgram
import edu.upb.lp.isc.losCheetos.ParamCallExpression
import edu.upb.lp.isc.losCheetos.IfExpression
import edu.upb.lp.isc.losCheetos.IntExpression
import edu.upb.lp.isc.losCheetos.StrExpression
import edu.upb.lp.isc.losCheetos.PrintExpression
import edu.upb.lp.isc.losCheetos.ListExpression
import edu.upb.lp.isc.losCheetos.BoolConstant
import edu.upb.lp.isc.losCheetos.BoolNumCompExpression
import edu.upb.lp.isc.losCheetos.BoolCompExpression
import edu.upb.lp.isc.losCheetos.StrAppExpression
import edu.upb.lp.isc.losCheetos.StrLenExpression
import edu.upb.lp.isc.losCheetos.CarExpression
import edu.upb.lp.isc.losCheetos.CdrExpression
import edu.upb.lp.isc.losCheetos.LengthExpression
import edu.upb.lp.isc.losCheetos.EmptyExpression
import edu.upb.lp.isc.losCheetos.ConsExpression
import edu.upb.lp.isc.losCheetos.DoubleExpression
import org.w3c.dom.bootstrap.DOMImplementationRegistry
import edu.upb.lp.isc.losCheetos.FracExpression
import edu.upb.lp.isc.losCheetos.CompExpression
import edu.upb.lp.isc.losCheetos.ArithExpression
import edu.upb.lp.isc.losCheetos.WhileExpression
import edu.upb.lp.isc.losCheetos.FunctionCallExpression

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class LosCheetosGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
//		fsa.generateFile('greetings.txt', 'People to greet: ' + 
//			resource.allContents
//				.filter(Greeting)
//				.map[name]
//				.join(', '))
		val MyRacketProgram p = resource.contents.get(0) as MyRacketProgram
		fsa.generateFile('test.py', generate(p))
	}

	def generate(MyRacketProgram p) '''
		import math
		«FOR d : p.defines»
			«generateD(d)»
		«ENDFOR»
		
		«FOR e : p.executions»
			print(«generate(e)»)
		«ENDFOR»
	'''

	def generateD(Define d) '''
		def «d.name»(«d.params.join(', ')»):
			«FOR e : d.body»
				«generate(e)»
			«ENDFOR»
	'''

	def generate(Expression e) '''
		«IF e instanceof IntExpression»
			«val IntExpression d = e as IntExpression»
			«d.value»
		«ELSEIF e instanceof StrExpression»
			«val StrExpression d = e as StrExpression»
			"«d.value»"
		«ELSEIF e instanceof PrintExpression»
			«val PrintExpression d = e as PrintExpression»
			«generateP(d)»
		«ELSEIF e instanceof ListExpression»
			«val ListExpression d = e as ListExpression»
			[«generateL(d)»]
		«ELSEIF e instanceof BoolConstant»
			«val BoolConstant d = e as BoolConstant»
			«IF d.value»
				True
			«ELSE»
				False
			«ENDIF»
		«ELSEIF e instanceof BoolNumCompExpression»
			«val BoolNumCompExpression d = e as BoolNumCompExpression»
			«generateBN(d)»
		«ELSEIF e instanceof BoolCompExpression»
			«val BoolCompExpression d = e as BoolCompExpression»
			«generateB(d)»
		«ELSEIF e instanceof StrAppExpression»
			«val StrAppExpression d = e as StrAppExpression»
			«generateSA(d)»
		«ELSEIF e instanceof StrLenExpression»
			«val StrLenExpression d = e as StrLenExpression»
			len("«d.str.value»")
		«ELSEIF e instanceof CarExpression»
			«val CarExpression d = e as CarExpression»
			«generateLO(d.list)»[0]
		«ELSEIF e instanceof CdrExpression»
			«val CdrExpression d = e as CdrExpression»
			«generateLO(d.list)»[1:]
		«ELSEIF e instanceof LengthExpression»
			«val LengthExpression d = e as LengthExpression»
			len(«generateLO(d.list)»)
		«ELSEIF e instanceof EmptyExpression»
			«val EmptyExpression d = e as EmptyExpression»
			len(«generateLO(d.list)») == 0
		«ELSEIF e instanceof ConsExpression»
			«val ConsExpression d = e as ConsExpression»
			«var ListExpression l = d.list as ListExpression»
			«l.args.add(0,d.expr)»
			[«generateL(l)»]
		«ELSEIF e instanceof ParamCallExpression»
			«val ParamCallExpression d = e as ParamCallExpression»
			«d.param»
		«ELSEIF e instanceof DoubleExpression»
			«val DoubleExpression d = e as DoubleExpression»
			«d.int».«d.dec»
		«ELSEIF e instanceof FracExpression»
			«val FracExpression d = e as FracExpression»
			«d.num»/«d.dec»
		«ELSEIF e instanceof CompExpression»
			«val CompExpression d = e as CompExpression»
			complex(«d.real», «d.imag»)
		«ELSEIF e instanceof ArithExpression»
			«val ArithExpression d = e as ArithExpression»
			«generateA(d)»
		«ELSEIF e instanceof FunctionCallExpression»
			«val FunctionCallExpression d = e as FunctionCallExpression»
			«d.function.name»(«generateArgs(d)»)
		«ELSEIF e instanceof IfExpression»
			«val IfExpression d = e as IfExpression»
			«generateIf(d)»
		«ELSEIF e instanceof WhileExpression»
			«val WhileExpression d = e as WhileExpression»
			«generateWhile(d)»
		«ENDIF»
	'''

	def generateP(PrintExpression p) '''
		«generate(p.expr)»
	'''

	def generateL(ListExpression l) '''
		«IF l.args.length > 0»
			«FOR e: l.args»
				«generate(e)»,
			«ENDFOR»
		«ENDIF»
	'''

	def generateBN(BoolNumCompExpression b) '''
		«val String eq = "="»
		«IF b.comp.equals(eq)»
			«generate(b.e1)» == «generate(b.e2)»
		«ELSE»
			«generate(b.e1)» «b.comp» «generate(b.e2)»
		«ENDIF»
	'''

	def generateB(BoolCompExpression b) '''
		«generate(b.e1)» == «generate(b.e2)»
	'''

	def generateSA(StrAppExpression s) '''
		«generate(s.str1)» + «generate(s.str2)»
	'''

	def generateLO(Expression e) '''
		«generate(e)»
	'''

	def generateA(ArithExpression a) '''
		(«generate(a.arg1)») «FOR e : a.oargs» «a.op» («generate(e)») «ENDFOR»
	'''

	def generateArgs(FunctionCallExpression f) '''
		«IF f.args.length > 0»
			«FOR e: f.args»
				«generate(e)»,
			«ENDFOR»
		«ENDIF»
	'''

	def generateIf(IfExpression i) '''
		if («generate(i.cond)»):
			«generate(i.then)»
		else:
			«generate(i.^else)»
	'''

	def generateWhile(WhileExpression w) '''
		while(«generate(w.cond)»):
			«FOR e : w.^do»
				«generate(e)»
			«ENDFOR»
	'''

}
