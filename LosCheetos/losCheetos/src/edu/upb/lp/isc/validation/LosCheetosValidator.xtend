/*
 * generated by Xtext 2.11.0
 */
package edu.upb.lp.isc.validation

import edu.upb.lp.isc.losCheetos.LosCheetosPackage
import edu.upb.lp.isc.losCheetos.FunctionCallExpression
import edu.upb.lp.isc.losCheetos.ParamCallExpression
import org.eclipse.emf.ecore.EObject
import edu.upb.lp.isc.losCheetos.Define
import org.eclipse.xtext.validation.Check
import edu.upb.lp.isc.losCheetos.MyRacketProgram
import edu.upb.lp.isc.losCheetos.IntExpression
import edu.upb.lp.isc.losCheetos.FracExpression

/**
 * This class contains custom validation rules. 
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class LosCheetosValidator extends AbstractLosCheetosValidator {

//	public static val INVALID_NAME = 'invalidName'
//
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					LosCheetosPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}
	@Check
	def checkFunctionCallNumberOfArguments(FunctionCallExpression e) {
		if (e.args.length != e.function.params.length) {
			error("Number of parameters does not match with number of arguments.",
				LosCheetosPackage.Literals.FUNCTION_CALL_EXPRESSION__ARGS)
		}
	}

	@Check
	def checkDefineParams(ParamCallExpression p) {
		var boolean keep1 = true
		var EObject o = p
		while (!(o instanceof Define) && keep1) {
			o = o.eContainer
			if (o instanceof MyRacketProgram) {
				keep1 = false
			}
		}
		if (keep1) {
			val Define d = o as Define
			var boolean keep = true
			for (e : d.params) {
				if (e == p.param) {
					keep = false
				}
			}
			if (keep) {
				error("Undefined parameter.", LosCheetosPackage.Literals.PARAM_CALL_EXPRESSION__PARAM)
			}
		} else {
			error("Can not call a parameter in the executions.",
				LosCheetosPackage.Literals.PARAM_CALL_EXPRESSION__PARAM)
		}
	}

	@Check
	def checkDefineName(Define d) {
		var EObject o = d.eContainer
		val MyRacketProgram m = o as MyRacketProgram
		for (e : m.defines) {
			if (d.name == e.name && !(d.equals(e))) {
				error("Another define has the same name.", LosCheetosPackage.Literals.DEFINE__NAME)
			}
		}
	}

	@Check
	def checkDefineNameType(Define d) {
		val char i = 'i'
		val char b = 'b'
		val char s = 's'
		val char l = 'l'
		if (d.name.charAt(0) != i && d.name.charAt(0) != b && d.name.charAt(0) != s && d.name.charAt(0) != l) {
			error("A define must return a list, boolean, string or an int.", LosCheetosPackage.Literals.DEFINE__NAME)
		}
	}

	// @Check
	def checkParamAndArgType(FunctionCallExpression f) {
		val char i = 'i'
		val int len = f.args.length
		val Define d = f.function as Define
		if (len > 0) {
			for (var int c = 0; c < len; c++) {
				if (((d.params.get(c).charAt(0) == i) && !(f.args.get(c) instanceof IntExpression))) {
					error("Argument and parameter are not of the same type.",
						LosCheetosPackage.Literals.FUNCTION_CALL_EXPRESSION__ARGS)
				}
			}
		}
	}

	@Check
	def checkMathError(FracExpression f) {
		val int c = 0
		if (f.dec.equals(c)) {
			error("Can't divide a number by 0", LosCheetosPackage.Literals.FRAC_EXPRESSION__DEC)
		}
	}

}
